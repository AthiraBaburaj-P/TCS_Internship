# -*- coding: utf-8 -*-
"""INTERNSHIP_AthiraBaburaj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DUArZKnyUWlhRHGswtjX4rY87yb47twb

**IMPORTING NECESSARY LIBRARIES**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""***IMPORTING THE DATASET ***"""

file_id = '1-gqmVKSU7RR6cIb7ghy6oHh-GGVvQIw1'
file_url = f'https://drive.google.com/uc?id={file_id}'
data = pd.read_csv(file_url)

data

"""**BASIC DETAILS**"""

data.head()

data.shape

data.columns

data.duplicated().value_counts()

# Use the drop_duplicates method to remove duplicate rows
data = data.drop_duplicates()

data.shape

data['NAME'].nunique()

data['GENDER'].nunique()

data['DRUG NAME'].nunique()

data['AGE'].nunique()

data['RACE'].nunique()

data['SIDE EFFECTS'].nunique()

data.info()

data.dtypes

data.describe()

data['NAME'].unique()

data['GENDER'].unique()

data['DRUG NAME'].unique()

data['RACE'].unique()

data['AGE'].unique()

data['SIDE EFFECTS'].unique()

"""**IDENTIFYING MISSING VALUES**"""

data.isna().sum()

"""#There are missing values in the AGE.

## **EDA**

UNIVARIATE ANALYSIS
"""

#NAME

#Drop the column "Name" which doesn't give any contribution for the modelling
data = data.drop(['NAME'], axis = 1)

data

#RACE

data['RACE'].value_counts()

data['RACE'].value_counts(normalize=True)

plt.figure(figsize=(12, 6))
sns.countplot(x='RACE', data=data, order=data['RACE'].value_counts().index)
plt.title('Counts of RACE')
plt.xlabel('RACE')
plt.ylabel('Count')
plt.xticks(rotation=90)
plt.show()

#AMONG THE PATIENTS MAJORITY ARE WHITES AND CHINESE ARE MINORITY

#GENDER

data['GENDER'].value_counts()

data['GENDER'].value_counts(normalize=True)

data['GENDER'].value_counts().plot.bar()
plt.show()

#59.4% are females ,40.5% are males, FEMALES ARE MORE

#AGE

data['AGE'].min()

data['AGE'].max()

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'data' is your DataFrame containing the 'AGE' column

# Calculate value counts for 'AGE'
age_counts = data['AGE'].value_counts().sort_index()

# Create a bar plot for the value counts of 'AGE'
plt.figure(figsize=(20, 15))
sns.barplot(x=age_counts.index, y=age_counts.values)
plt.xlabel('AGE')
plt.ylabel('Count')
plt.title('Value Counts of AGE')
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.show()

pd.set_option('display.max_rows', None)

data['AGE'].value_counts()

# AGE IS A SKEWED DISTRIBUTION, AND MAJORITY PATIENTS ARE IN THE AGE GROUP OF 24-55.

#SIDE EFFECTS

data['SIDE EFFECTS'].value_counts()

data['SIDE EFFECTS'].value_counts(normalize=True)    #IMBALANCED DATA

# Calculate normalized value counts
normalized_counts = data['SIDE EFFECTS'].value_counts(normalize=True)

# Create a pie chart
plt.figure(figsize=(4, 4))
plt.pie(normalized_counts, labels=normalized_counts.index, autopct='%1.1f%%', startangle=140)
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.title('Normalized Distribution of Side Effects')
plt.show()

# PATIENTS WITH MILD EFFECTS  ARE THE 33.3%, PEOPLE WITH EXTREME SIDE EFFECTS ARE 5.8 % OF TOTAL PATIENTS

#DRUG NAME

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'data' is your DataFrame containing the drug names

top_n = 10  # Choose the number of top drugs to display

# Get the top N drugs and group the rest as "Others"
top_drugs = data['DRUG NAME'].value_counts().head(top_n)
#other_count = data['DRUG NAME'].value_counts().sum() - top_drugs.sum()

# Create a DataFrame for plotting
#plot_data = top_drugs.append(pd.Series({'Others': other_count}))

# Create a bar plot
plt.figure(figsize=(12, 6))
sns.barplot(x=top_drugs.index, y=top_drugs.values)
plt.title(f'Top {top_n} DRUG NAME')
plt.xlabel('DRUG NAME')
plt.ylabel('Count')
plt.xticks(rotation=45, ha='right')
plt.show()

pd.set_option('display.max_rows', None)

data['DRUG NAME'].value_counts()

#THE PLOT SHOWS THE TOP 10 DRUGS USED BY PATIENTS AND PAXIL TOPS THE LIST

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'data' is your DataFrame containing the drug names

bottom_n = 10  # Choose the number of bottom drugs to display

# Get the bottom N drugs
bottom_drugs = data['DRUG NAME'].value_counts().tail(bottom_n)

# Create a bar plot
plt.figure(figsize=(12, 6))
sns.barplot(x=bottom_drugs.index, y=bottom_drugs.values)
plt.title(f'Bottom {bottom_n} DRUG NAME')
plt.xlabel('DRUG NAME')
plt.ylabel('Count')
plt.xticks(rotation=45, ha='right')
plt.show()

drug_counts = data['DRUG NAME'].value_counts()
drug_names_with_8_counts = drug_counts[drug_counts == 8].index.tolist()
drug_names_with_8_counts

len(drug_names_with_8_counts)

#THE ABOVE CODE SHOWS THAT 101 DRUGS ARE LEAST PREFERRED

"""***BIVARIATE ANALYSIS***"""

#GENDER VS AGE

age_groups = ['0-4', '5-9', '10-14', '15-19', '20-24', '25-29', '30-34', '35-39', '40-44', '45-49', '50-54', '55-59', '60-64', '65-69', '70-74', '75+']

# Create a contingency table with age groups
contingency_table = pd.crosstab(pd.cut(data['AGE'], bins=range(0, 81, 5), labels=age_groups), data['GENDER'])

print(contingency_table)

# Plot the contingency table
contingency_table.plot(kind='bar', figsize=(20, 10))
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.legend(title='Age Group')
plt.show()

#MAJORITY PATIENTS ARE IN THE AGE GROUP OF 20-59, AND OUT OF THAT TOO FEMALES ARE HIGHER THAN MALES IN ALL GROUPS

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'data' is your DataFrame containing the 'AGE' and 'GENDER' columns

# Filter the data to include ages up to 100
data_filtered = data[data['AGE'] <= 100]

plt.figure(figsize=(12, 7))
sns.boxplot(x='GENDER', y='AGE', data=data_filtered)
plt.xlabel('Gender')
plt.ylabel('Age')
plt.title('Age Distribution by Gender (Ages up to 100)')
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.show()

#INFERENCE TO BE NOTED : IRRESPECTIVE OF GENDER PEOPLE OF SAME AGE ARE SUFFERING FROM ILLNESS

#GENDER VS SIDE EFFECTS

import pandas as pd

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['SIDE EFFECTS'], margins=True, margins_name='Total')

contingency_table

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['SIDE EFFECTS'], margins=True, margins_name='Total')

# Separate contingency table for Male and Female
male_table = contingency_table.loc['M']
female_table = contingency_table.loc['F']

# Calculate percentages for Male and Female
male_percentages = male_table / male_table['Total'] * 100
female_percentages = female_table / female_table['Total'] * 100

# Plot pie chart for Male
plt.figure(figsize=(8, 4))
plt.pie(male_percentages[:-1], labels=male_percentages.index[:-1], autopct='%1.1f%%', startangle=140)
plt.title("Side Effects Distribution - Male")
plt.show()

# Plot pie chart for Female
plt.figure(figsize=(8, 4))
plt.pie(female_percentages[:-1], labels=female_percentages.index[:-1], autopct='%1.1f%%', startangle=140)
plt.title("Side Effects Distribution - Female")
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['SIDE EFFECTS'], margins=True, margins_name='Total')

# Separate contingency table for Male and Female
male_table = contingency_table.loc['M']
female_table = contingency_table.loc['F']

# Calculate percentages for Male and Female
male_percentages = (male_table / male_table['Total'])[:-1] * 100
female_percentages = (female_table / female_table['Total'])[:-1] * 100

# Plot bar chart for Male
plt.figure(figsize=(8, 6))
ax = male_percentages.plot(kind='bar', color='blue', alpha=0.7)
plt.title("Side Effects Distribution - Male")
plt.xlabel("Side Effects")
plt.ylabel("Percentage (%)")
plt.xticks(rotation=45)
plt.tight_layout()

# Add percentages above the bars
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}%', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center')

plt.show()

# Plot bar chart for Female
plt.figure(figsize=(8, 6))
ax = female_percentages.plot(kind='bar', color='pink', alpha=0.7)
plt.title("Side Effects Distribution - Female")
plt.xlabel("Side Effects")
plt.ylabel("Percentage (%)")
plt.xticks(rotation=45)
plt.tight_layout()

# Add percentages above the bars
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}%', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center')

plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'contingency_table' is your DataFrame containing the contingency table data

plt.figure(figsize=(12, 8))

# Create a stacked bar plot
ax = contingency_table.plot(kind='bar', stacked=True, figsize=(12, 8))

# Iterate through each bar
for container in ax.containers:
    # Iterate through each segment of the bar
    for p in container.patches:
        width, height = p.get_width(), p.get_height()
        x, y = p.get_x(), p.get_y()

        # Display the value counts at the center of each segment
        ax.annotate(f'{int(height)}', (x + width / 2, y + height / 2), ha='center', va='center', fontsize=10, color='black')

plt.xlabel('GENDER')
plt.ylabel('Count')
plt.title('Gender vs SIDE EFFECTS (Value Counts)')
plt.xticks(rotation=0)  # Rotate x-axis labels if needed
plt.legend(title='SIDE EFFECTS')
plt.show()

# IRRESPECTIVE OF THE GENDER ,PATIENTS WITH MILD SIDE EFFECTS ARE MAX, AND THOSE WITH EXTREME SEVERE SIDE EFFECTS ARE MIN.

#GENDER VS RACE

import pandas as pd

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['RACE'], margins=True, margins_name='Total')

contingency_table

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['RACE'], margins=True, margins_name='Total')

# Separate contingency table for Male and Female
male_table = contingency_table.loc['M']
female_table = contingency_table.loc['F']

# Calculate percentages for Male and Female
male_percentages = (male_table / male_table['Total'])[:-1] * 100
female_percentages = (female_table / female_table['Total'])[:-1] * 100

# Plot bar chart for Male
plt.figure(figsize=(8, 6))
ax = male_percentages.plot(kind='bar', color='blue', alpha=0.7)
plt.title("RACE Distribution - Male")
plt.xlabel("RACE")
plt.ylabel("Percentage (%)")
plt.xticks(rotation=45)
plt.tight_layout()

# Add percentages above the bars
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}%', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center')

plt.show()

# Plot bar chart for Female
plt.figure(figsize=(8, 6))
ax = female_percentages.plot(kind='bar', color='pink', alpha=0.7)
plt.title("RACE - Female")
plt.xlabel("RACE")
plt.ylabel("Percentage (%)")
plt.xticks(rotation=45)
plt.tight_layout()

# Add percentages above the bars
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}%', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center')

plt.show()

# MOJORITY PATIENTS ARE WHITES ,CHINESE ARE MINORITY

#GENDER VS DRUG NAME

contingency_table = pd.crosstab(data['GENDER'], data['DRUG NAME'])
# Sort the drug names based on their counts in descending order
sorted_drugs = contingency_table.sum().sort_values(ascending=False)

# Select the top 10 drug names
top_10_drugs = sorted_drugs.head(10)

# Create a DataFrame with the selected drug names
selected_contingency = contingency_table[top_10_drugs.index]
# Create a bar plot
plt.figure(figsize=(25, 20))
selected_contingency.T.plot(kind='bar')

plt.xlabel('Drug Names')
plt.ylabel('Count')
plt.title('Stacked Bar Plot of Gender vs. Top 10 Drug Names (Excluding Total)')
plt.legend(title='Gender', loc='upper right')
plt.xticks(rotation=90)
plt.show()

"""*   paxil - depression/anxiety
*   lamictal - bi-polar disorder, depression
*   levoxyl - low thyroid production
*   nexium - gerd/barret's esophogus, acid reflux
*   ambien - insomnia
*   lexapro - depression
*   citalopram - depression
*   prozac - depression
*   retin-a - clearing skin
*   effexor - depression

"""

import pandas as pd

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['DRUG NAME'], margins=True, margins_name='Total')

# Remove the 'Total' column
contingency_table = contingency_table.drop('Total', axis=1)

# Get the top 10 drug names for both Male and Female
top_10_male_drugs = contingency_table.loc['M'].nlargest(10).index.tolist()
top_10_female_drugs = contingency_table.loc['F'].nlargest(10).index.tolist()

# Filter the DataFrame for Male and Female separately
male_data = data[data['GENDER'] == 'M']
female_data = data[data['GENDER'] == 'F']

# Get value counts for the top 10 drugs for Male
male_top_10_counts = male_data[male_data['DRUG NAME'].isin(top_10_male_drugs)]['DRUG NAME'].value_counts()

# Get value counts for the top 10 drugs for Female
female_top_10_counts = female_data[female_data['DRUG NAME'].isin(top_10_female_drugs)]['DRUG NAME'].value_counts()

print("Value Counts for Top 10 Drugs for Males:")
print(male_top_10_counts)

print("\nValue Counts for Top 10 Drugs for Females:")
print(female_top_10_counts)

# Assuming 'data' is your DataFrame
contingency_table = pd.crosstab(data['GENDER'], data['DRUG NAME'], margins=True, margins_name='Total')

# Separate contingency table for Male and Female
male_table = contingency_table.loc['M']
female_table = contingency_table.loc['F']

# Remove the 'Total' column and sort by the counts in descending order
male_top_10 = male_table.drop('Total').sort_values(ascending=False).head(10)
female_top_10 = female_table.drop('Total').sort_values(ascending=False).head(10)
# Plot bar chart for Male with percentages
plt.figure(figsize=(10, 6))
ax = male_top_10.plot(kind='bar', color='blue', alpha=0.7)
plt.title("Top 10 Drugs for Males")
plt.xlabel("Drug Name")
plt.ylabel("Count")
plt.xticks(rotation=45)

# Annotate percentages above the bars
total_male = male_top_10.sum()
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height/total_male:.1%}', (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom')

plt.tight_layout()
plt.show()
# Plot bar chart for Female with percentages
plt.figure(figsize=(10, 6))
ax = female_top_10.plot(kind='bar', color='pink', alpha=0.7)
plt.title("Top 10 Drugs for Females")
plt.xlabel("Drug Name")
plt.ylabel("Count")
plt.xticks(rotation=45)
# Annotate percentages above the bars
total_female = female_top_10.sum()
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height/total_female:.1%}', (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom')

plt.tight_layout()
plt.show()

#TOP 10 DRUGS USED BY MALES AND FEMALES ARE SAME , THIS INDICATES BOTH HAVE SIMILAR HEALTH ISSUES ,mostly they are affected by depression or mental health issues

#DRUG NAME VS AGE

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame containing the 'DRUG NAME' and 'AGE' columns

# Get the top 10 drug names
top_n = 10
top_drugs = data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data to include only the top 10 drug names
filtered_data = data[data['DRUG NAME'].isin(top_drugs)]

# Create a box plot for the top 10 drug names vs. age
plt.figure(figsize=(12, 8))
sns.boxplot(x='DRUG NAME', y='AGE', data=filtered_data, palette='Set2')
plt.xlabel('Drug Name')
plt.ylabel('Age')
plt.title(f'Top {top_n} Drug Names vs. Age')
plt.xticks(rotation=45, ha='right')

# Set the y-axis limits to show ages only up to 100
plt.ylim(0, 100)

plt.show()

#Lamictal (lamotrigine) is an anticonvulsant used to treat epilepsy and bipolar disorder,most of the patients are in the age group of 40 to 55.

#retin-a: youngsters are taking :used for skin conditions such as acne, wrinkles, hyperpigmentation, and rough texture.

#citalopram:preferred more by older patients :used as an antidepressant medication used to treat depression and certain anxiety disorders.

#effexor: preferred by older patients:antidepressant that is used to treat major depressive disorder, generalized anxiety disorder, and panic disorder.

# while Levoxyl (levothyroxine) is a thyroid hormone replacement medication used to treat hypothyroidism.

#DRUG NAME VS RACE

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame containing 'DRUG NAME' and 'RACE' columns

# Get the top 10 drug names
top_n = 10
top_drugs = data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data to include only the top 10 drug names
filtered_data = data[data['DRUG NAME'].isin(top_drugs)]

# Create a DataFrame with counts of drug usage by race
drug_race_counts = filtered_data.groupby(['DRUG NAME', 'RACE']).size().unstack(fill_value=0)

# Plot a grouped bar plot
ax = drug_race_counts.plot(kind='bar', stacked=True, figsize=(12, 8))
plt.xlabel('Drug Name')
plt.ylabel('Count')
plt.title('Top 10 Drug Names vs. Race')
plt.legend(title='Race', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(rotation=45, ha='right')
plt.show()

import pandas as pd

# Assuming 'data' is your DataFrame containing 'DRUG NAME' and 'RACE' columns

# Get the top 10 drug names
top_n = 10
top_drugs = data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data to include only the top 10 drug names
filtered_data = data[data['DRUG NAME'].isin(top_drugs)]

# Create a crosstab between the filtered 'DRUG NAME' and 'RACE'
cross_tab = pd.crosstab(filtered_data['DRUG NAME'], filtered_data['RACE'])

# Display the crosstab
cross_tab

#these top 10 drugs are generally preferred by whites ,hispanic whites and blacks ,THESE PEOPLE SUFFER WITH COMMON ILLNESS THAT IS DEPRESSION .

#DRUG NAME VS SIDE EFFECTS

import seaborn as sns
import matplotlib.pyplot as plt

# Filter the DataFrame to include only the top 10 drug names
drugname_counts = data['DRUG NAME'].value_counts()
top_10_drug_names = drugname_counts.head(10).index.tolist()
filtered_df = data[data['DRUG NAME'].isin(top_10_drug_names)]

# Create a countplot for Drug Name vs. Side Effects
plt.figure(figsize=(10, 6))  # Adjust the figure size as needed
sns.countplot(x='DRUG NAME', hue='SIDE EFFECTS', data=filtered_df)

# Set the title and labels for the plot
plt.title('Drug Name vs. Side Effects (Top 10 Drugs)')
plt.xlabel('Drug Name')
plt.ylabel('Count')

# Rotate x-axis labels for better readability if needed
plt.xticks(rotation=45)

# Display the plot
plt.legend(title='Side Effects', loc='upper right')  # Add legend
plt.tight_layout()
plt.show()

#contingency table

import pandas as pd

# Assuming 'data' is your DataFrame
# Get the top 10 drug names
top_10_drugs = data['DRUG NAME'].value_counts().nlargest(10).index.tolist()

# Filter the DataFrame to include only the top 10 drugs
data_filtered = data[data['DRUG NAME'].isin(top_10_drugs)]

# Create the contingency table for top 10 drugs vs. side effects
contingency_table1 = pd.crosstab(data_filtered['DRUG NAME'], data_filtered['SIDE EFFECTS'])

print("Contingency Table for Top 10 Drug Names vs. Side Effects:")
contingency_table1

df=contingency_table1
df['Sum'] = df['Mild Side Effects'] + df['No Side Effects']
df

#AMBIEN ,CITALOPRAM ,NEXIUM , RETIN-A ARE THE ONES HAVING NO CASE OF EXTREME SIDE EFFECTS,but all have severe side effects only nexium out of this is having least patients with severe side effects too

#nexium ,paxil and lamictal are the drugs which are either having very mild side efefcts or no side effects at all .

#AGE VS RACE

import pandas as pd

# Assuming 'data' is your DataFrame containing the 'AGE' and 'RACE' columns

# Filter the data to include ages up to 100
filtered_data = data[data['AGE'] <= 100]

# Create a contingency table
contingency_table = pd.crosstab(filtered_data['AGE'], filtered_data['RACE'])

plt.figure(figsize=(15, 12))
filtered_data = data[data['AGE'] <= 100]  # Filter data for ages up to 100
sns.boxplot(x='RACE', y='AGE', data=filtered_data)
plt.title('RACE vs AGE (Ages up to 100)')
plt.show()

#china and asian indian have only young patients ,white ,hiSpanic white and blacks have patients from young age to senior citizens

#AGE VS SIDE EFFECTS

import pandas as pd

# Assuming 'AGE' and 'CATEGORY' are the column names in your dataset
# Create age bins with three groups: 0-30, 31-60, and 60 above
age_bins = pd.cut(data['AGE'], bins=[0, 30, 60, float('inf')], labels=['0-30', '31-60', '60+'])
contingency_table = pd.crosstab(age_bins, data['SIDE EFFECTS'])

# Display the contingency table
print(contingency_table)

# Plot the contingency table as a bar plot
ax = contingency_table.plot(kind='bar', figsize=(10, 6))

# Set labels and title
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.title('Side Effects by Age Group')

# Display the legend
plt.legend(title='Side Effects', loc='upper right')

# Rotate x-axis labels for better readability
plt.xticks(rotation=0)

# Show the plot
plt.show()

#Severity Trends: Across all age groups, "Mild Side Effects" are consistently the most reported, followed by "Moderate Side Effects." However, the prevalence of "Severe Side Effects" and "Extremely Severe Side Effects" tends to increase with age, with the 60+ age group having a relatively higher proportion of these severe side effects.

#RACE VS SIDE EFFECTS(RECONSIDER INFERENCE)

plt.figure(figsize=(15, 10))  # Adjust the width and height as needed
sns.countplot(x='SIDE EFFECTS', hue='RACE', data=data)
plt.xlabel('SIDE EFFECTS')
plt.ylabel('Count')
plt.title('Race VS Side Effects')
plt.show()

#BLACKS  ARE SHOWING EXTREME SEVERE SIDE EFFECTS COMPARED TO HISPANIC WHITE ,BLACKS ARE SHOWING MODERATE SIDE EFFECTS A BIT HIGHER COMPARED TO HISPANIC WHITE

"""MULTIVARIATE ANALYSIS"""

#DRUG NAME VS GENDER VS AGE

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame containing the 'DRUG NAME', 'GENDER', and 'AGE' columns

# Filter the data to include ages up to 100
filtered_data = data[data['AGE'] <= 100]

# Get the top 10 drug names from the filtered data
top_n = 10
top_drugs = filtered_data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data again to include only the top 10 drug names
filtered_data = filtered_data[filtered_data['DRUG NAME'].isin(top_drugs)]

# Create a box plot for the top 10 drug names vs. gender for ages up to 100
plt.figure(figsize=(12, 8))
sns.boxplot(x='DRUG NAME', y='AGE', hue='GENDER', data=filtered_data, palette='Set2')
plt.xlabel('Drug Name')
plt.ylabel('Age')
plt.title(f'Top {top_n} Drug Names vs. Gender for Ages up to 100')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Gender')
plt.show()
   #age vs drug name vs side effect try this

##younger patients are having skin concerns (males are higher than females ), older patients are suffering from depression irrespective of gender

#age vs top 10 drug name vs race( COULD NOT FIND INFERENCE ON THIS PLOT )

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'data' is your DataFrame containing the 'AGE', 'DRUG NAME', and 'RACE' columns

# Filter the data to include ages up to 100
filtered_data = data[data['AGE'] <= 100]

# Get the top 10 drug names from the filtered data
top_n = 10
top_drugs = filtered_data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data again to include only the top 10 drug names
filtered_data = filtered_data[filtered_data['DRUG NAME'].isin(top_drugs)]

# Calculate the average age for each combination of 'Drug Name' and 'Race'
age_by_drug_race = filtered_data.groupby(['DRUG NAME', 'RACE'])['AGE'].mean().reset_index()

# Create a grouped bar chart
plt.figure(figsize=(12, 8))
sns.barplot(x='DRUG NAME', y='AGE', hue='RACE', data=age_by_drug_race, palette='Set1')
plt.title('Multivariate Analysis: Age up to 100 vs. Top 10 Drug Names vs. Race')
plt.xlabel('Drug Name')
plt.ylabel('Average Age')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Race')
plt.show()          #DISCUSS RELEVANCE OF INFERENCE

#BLACKS ABOVE 45 ARE USING 9 OUT OF 10 DRUGS ,30-47 YRS WHITES ARE USING ALL DRUGS ,ASIAN INDIANS ARE USING ONLY 2 DRUGS ,AMBIEN IS USED BY OTHERS ,CITALOPRAM IS USED BY

#age vs side effects vs top 10 drug name(no clear inference)

import pandas as pd

# Assuming 'data' is your DataFrame containing the 'AGE', 'DRUG NAME', and 'SIDE EFFECTS' columns

# Define age bins for three categories: 0-30, 31-60, and 61+
age_bins = [0, 30, 60, 150]  # Adjust the upper limit as needed

# Create labels for the age bins
age_labels = ['0-30', '31-60', '61+']

# Add a new column 'AGE_GROUP' to the DataFrame with age group labels
data['AGE_GROUP'] = pd.cut(data['AGE'], bins=age_bins, labels=age_labels, include_lowest=True)

# Filter the data to include ages up to 100
filtered_data = data[data['AGE'] <= 100]

# Get the top 10 drug names used by people of all age groups
top_n = 10
top_drugs = filtered_data['DRUG NAME'].value_counts().head(top_n).index

# Filter the data to include only the top 10 drug names
filtered_data = filtered_data[filtered_data['DRUG NAME'].isin(top_drugs)]

# Create a contingency table
contingency_table = pd.crosstab([filtered_data['AGE_GROUP'], filtered_data['DRUG NAME']], filtered_data['SIDE EFFECTS'])

# Display the contingency table
contingency_table

"""**PRE PROCESSING**"""

#HANDLING MISSING VALUES

import pandas as pd

# Assuming 'data' is your DataFrame containing the 'AGE_GROUP' column

# Use the drop method to remove the 'AGE_GROUP' column
data = data.drop('AGE_GROUP', axis=1)

print("Percentage of missing values in each column:")
print(100 * data.isnull().sum() / len(data))

data

# Calculate the median age (excluding missing values)
median_age = data['AGE'].median()

# Fill missing values in the 'AGE' column with the calculated median age
data['AGE'].fillna(median_age, inplace=True)

data.isna().sum()

#FINDING OUTLIERS AND HANDLING THEM

plt.boxplot(data['AGE'])
plt.title('Boxplot for AGE')

q1 = np.percentile(data['AGE'], 25)
q2 = np.percentile(data['AGE'], 50)
q3 = np.percentile(data['AGE'], 75)

iqr=q3-q1

low_limit = q1 - 1.5*iqr
upr_limit = q3 + 1.5*iqr

low_limit

upr_limit

outlier=[]
for x in data['AGE']:
    if x>upr_limit or x<low_limit:
        outlier.append(x)

outlier

ind1 = data['AGE']>upr_limit
ind2= data['AGE']<low_limit

data.loc[ind1].index

data.loc[ind2].index #no low outliers

data[ind1]['AGE']

data=data[data['AGE']<=100]

data['AGE'].value_counts()

#Encoding

# As the dataset is large, I am considering Label encoding

#LABEL ENCODING

label_columns = ['GENDER','RACE','DRUG NAME','SIDE EFFECTS']

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
for column in label_columns:
    data[column] = le.fit_transform(data[column])

data['DRUG NAME']

"""**CORRELATION**"""

plt.figure(figsize=(10,10))
corr_matrix=data.corr()
sns.heatmap(corr_matrix,vmin=-0.2,vmax=0.9,annot=True,cmap='YlGnBu')
plt.show

# No correlation between any features. So I am not dropping anything.

"""**Scaling**"""

# I am not doing scaling because scaling has to be done on continuous numerical columns. But in my dataset all are discrete.

"""**Train Test Splitting**"""

X=data.drop('SIDE EFFECTS',axis=1)
y=data['SIDE EFFECTS']

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.25,random_state=42)

print("X_train dataset: ", X_train.shape)
print("y_train dataset: ", y_train.shape)
print("X_test dataset: ", X_test.shape)
print("y_test dataset: ", y_test.shape)

"""**Model Selection Based on Metrics**"""

# I am Considering models which are not affected by the magnitude difference in each features.

data['SIDE EFFECTS'].value_counts()# multiclass classification

data['SIDE EFFECTS'].value_counts(normalize=True)

# It is an imbalanced dataset, so I am considering other metrics rather than accuracy

# DECISION TREE

from sklearn.tree import DecisionTreeClassifier
dt_clf=DecisionTreeClassifier()
dt_clf.fit(X_train,y_train)

y_pred=dt_clf.predict(X_test)

from sklearn.metrics import accuracy_score, confusion_matrix,precision_score,recall_score,f1_score
print('Accuracy = ',accuracy_score(y_test,y_pred))
print('Precision = ',precision_score(y_test,y_pred,average='weighted'))
print('Recall = ',recall_score(y_test,y_pred,average='weighted'))
print('F1 Score = ',f1_score(y_test,y_pred,average='weighted'))

# Random Forest

from sklearn.ensemble import RandomForestClassifier
rf_clf=RandomForestClassifier()
rf_clf.fit(X_train,y_train)

y_pred=rf_clf.predict(X_test)

print('Accuracy = ',accuracy_score(y_test,y_pred))
print('Precision = ',precision_score(y_test,y_pred,average='weighted'))
print('Recall = ',recall_score(y_test,y_pred,average='weighted'))
print('F1 Score = ',f1_score(y_test,y_pred,average='weighted'))

# GBM

from sklearn.ensemble import GradientBoostingClassifier


# Initialize the Gradient Boosting classifier
gbm_clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1, random_state=42)

# Train the classifier
gbm_clf.fit(X_train, y_train)

# Make predictions on the test data
y_pred = gbm_clf.predict(X_test)

print('Accuracy = ',accuracy_score(y_test,y_pred))
print('Precision = ',precision_score(y_test,y_pred,average='weighted'))
print('Recall = ',recall_score(y_test,y_pred,average='weighted'))
print('F1 Score = ',f1_score(y_test,y_pred,average='weighted'))

#Naive bayes

from sklearn.naive_bayes import GaussianNB

# Create a Gaussian Naive Bayes classifier
nb_clf = GaussianNB()

# Fit the Naive Bayes classifier to the training data
nb_clf.fit(X_train, y_train)

# Predict using the Naive Bayes classifier
y_pred = nb_clf.predict(X_test)
print('Accuracy = ',accuracy_score(y_test,y_pred))
print('Precision = ',precision_score(y_test,y_pred,average='weighted'))
print('Recall = ',recall_score(y_test,y_pred,average='weighted'))
print('F1 Score = ',f1_score(y_test,y_pred,average='weighted'))

#DECSION TREE IS THE BEST MODEL ON THE BASIS OF METRICS OTHER THAN ACCURACY

"""### ***CROSS VALIDATION ***"""

from sklearn.model_selection import StratifiedKFold
# Initialize the StratifiedKFold object
stratified_kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

# Lists to store precision, recall, and F1 scores for each fold
precision_scores_dt = []
recall_scores_dt = []
f1_scores_dt = []

# Perform cross-validation
for train_index, test_index in stratified_kfold.split(X, y):
    X_train_cv, X_test_cv = X.iloc[train_index], X.iloc[test_index]
    y_train_cv, y_test_cv = y.iloc[train_index], y.iloc[test_index]

    # Initialize the Decision Tree classifier
    dt_classifier = DecisionTreeClassifier(random_state=42)

    # Fit the classifier on the training data
    dt_classifier.fit(X_train_cv, y_train_cv)

    # Predict on the test data
    y_pred_cv = dt_classifier.predict(X_test_cv)

    # Calculate precision, recall, and F1 scores
    precision = precision_score(y_test_cv, y_pred_cv,average='weighted')
    recall = recall_score(y_test_cv, y_pred_cv,average='weighted')
    f1 = f1_score(y_test_cv, y_pred_cv,average='weighted')

    precision_scores_dt.append(precision)
    recall_scores_dt.append(recall)
    f1_scores_dt.append(f1)

# Calculate and print the mean precision, recall, and F1 scores across all folds
mean_precision = sum(precision_scores_dt) / len(precision_scores_dt)
mean_recall = sum(recall_scores_dt) / len(recall_scores_dt)
mean_f1 = sum(f1_scores_dt) / len(f1_scores_dt)

print("Mean Precision:", mean_precision)
print("Mean Recall:", mean_recall)
print("Mean F1 Score:", mean_f1)

"""HYPERPARAMETER TUNING"""

from sklearn.model_selection import RandomizedSearchCV

# Define the hyperparameter grid for Decision Tree
dt_params = {
    'criterion': ['gini', 'entropy'],
    'splitter': ['best', 'random'],
    'max_depth': [None, 10, 20, 30, 40, 50],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'max_features': [None, 'sqrt', 'log2','auto'],
    'random_state': [None, 42],
}

# Create a Decision Tree classifier
dt_model = DecisionTreeClassifier()

# Initialize RandomizedSearchCV
cv_model_dt = RandomizedSearchCV(estimator=dt_model, param_distributions=dt_params,
                                 scoring='f1_weighted', n_jobs=-1, return_train_score=True,
                                 cv=StratifiedKFold(n_splits=5, shuffle=True, random_state=42))

# Fit the randomized search to your training data
cv_model_dt.fit(X_train_cv, y_train_cv)

# Get the best hyperparameters for Decision Tree
best_params_dt = cv_model_dt.best_params_

# Print the best parameters
print("Best Parameters for Decision Tree (F1 Weighted Score):", best_params_dt)

# Use the best hyperparameters obtained from RandomizedSearchCV
best_params_dt = {
    'splitter': 'random',
    'random_state': None,
    'min_samples_split': 10,
    'min_samples_leaf': 1,
    'max_features': None,
    'max_depth': 50,
    'criterion': 'entropy'
}

# Create a new Decision Tree classifier with the best hyperparameters
best_dt_model = DecisionTreeClassifier(**best_params_dt)

# Fit the model to your training data
best_dt_model.fit(X_train_cv, y_train_cv)

# Predict on the test data
y_pred_dt = best_dt_model.predict(X_test_cv)

# Calculate precision, recall, and F1-score
precision_dt = precision_score(y_test_cv, y_pred_dt, average='weighted')
recall_dt = recall_score(y_test_cv, y_pred_dt, average='weighted')
f1_dt = f1_score(y_test_cv, y_pred_dt, average='weighted')

# Print the evaluation metrics
print("Precision (Decision Tree):", precision_dt)
print("Recall (Decision Tree):", recall_dt)
print("F1 Score (Decision Tree):", f1_dt)

